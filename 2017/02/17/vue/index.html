<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>vue | Welcome to 拉不拉卡&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Vue Atom使用vue  install  langage-vue  1.使用Vue脚手架新建项目//全局安装 vue-cli cnpm install -g vue-cli  //创建一个基于 &amp;quot;webpack&amp;quot; 模板的新项目 vue init webpack                 my-project  //安装依赖，走你 cd my-project  //安">
<meta name="keywords" content="vue,vuex,vue-router,webpack">
<meta property="og:type" content="article">
<meta property="og:title" content="vue">
<meta property="og:url" content="http://yoursite.com/2017/02/17/vue/index.html">
<meta property="og:site_name" content="Welcome to 拉不拉卡's blog">
<meta property="og:description" content="Vue Atom使用vue  install  langage-vue  1.使用Vue脚手架新建项目//全局安装 vue-cli cnpm install -g vue-cli  //创建一个基于 &amp;quot;webpack&amp;quot; 模板的新项目 vue init webpack                 my-project  //安装依赖，走你 cd my-project  //安">
<meta property="og:updated_time" content="2017-04-27T10:08:25.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="vue">
<meta name="twitter:description" content="Vue Atom使用vue  install  langage-vue  1.使用Vue脚手架新建项目//全局安装 vue-cli cnpm install -g vue-cli  //创建一个基于 &amp;quot;webpack&amp;quot; 模板的新项目 vue init webpack                 my-project  //安装依赖，走你 cd my-project  //安">
  
    <link rel="alternate" href="/atom.xml" title="Welcome to 拉不拉卡&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Welcome to 拉不拉卡&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-vue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/02/17/vue/" class="article-date">
  <time datetime="2017-02-17T07:05:41.000Z" itemprop="datePublished">2017-02-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      vue
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a><a href="https://vuefe.cn/v2/guide/" target="_blank" rel="external">Vue</a></h1><p><strong> Atom使用vue  install  langage-vue </strong></p>
<h2 id="1-使用Vue脚手架新建项目"><a href="#1-使用Vue脚手架新建项目" class="headerlink" title="1.使用Vue脚手架新建项目"></a>1.使用Vue脚手架新建项目</h2><pre><code>//全局安装 vue-cli
cnpm install -g vue-cli

//创建一个基于 &quot;webpack&quot; 模板的新项目
vue init webpack                 my-project

//安装依赖，走你
cd my-project

//安装所需的模块
cnpm install
cnpm run dev
</code></pre><a id="more"></a>
<pre><code>（1）使用scss,   cnpm install node-sass sass-loader scss-loader - -save-dev(save前面两个-),&lt;style lang=“scss” scoped&gt; scoped是局部作用域
 (2)  安装出错 执行sudo rm -r -f ~/node_modules. ,重新install
  (3) 使用jquery 、vue-router ： cnpm install jquery —save-dev
</code></pre><h2 id="2-创建Vue实例"><a href="#2-创建Vue实例" class="headerlink" title="2.创建Vue实例"></a>2.创建Vue实例</h2><pre><code>var  vm = new Vue({
    el: ‘#div’,
    data: {            //数据
        a: 1
    },
    methods: {},        //方法
    watch:{},        //监听数据
    created: function(){
        //在实例创建后调用
    },
    computed:{
        b: function(){
            return this.a + 1
        }
    }
});
</code></pre><p>访问该实例的一些钩子属性：<br>vm.$data<br>vm.$el<br>…</p>
<p><strong> 当DOM更新后调用 </strong></p>
<pre><code>this/vm.$nextTick(function () {
    console.log(this.$el.textContent) // =&gt; &apos;updated&apos;
})
</code></pre><h2 id="3-Vue指令"><a href="#3-Vue指令" class="headerlink" title="3.Vue指令"></a>3.Vue指令</h2><pre><code>v-on:click=“clickMe”  等价于  @click=“clickMe”            //点击事件
v-on:keyup.enter=“save”  等价于   @keyup.enter=“save”    //按下回车键
v-bind:class=“{class1:true,class2:false}”            ==&gt;          class=“class1”
v-bind:class=“[class1,class2]”                ==&gt;           class=“class1 class2”
v-bind:style=“styleObject”               ==&gt;                 :style=“styleObject”
data: {
      styleObject: {
        color: &apos;red&apos;,
        fontSize: &apos;13px&apos;
      }
}
</code></pre><p>v-html=“xx”</p>
<p><strong> 循环 </strong></p>
<p>v-for=“item in items”   $index是当前循环的索引<br>v-for支持第二个参数作为当前项的索引<br>1.0版本  track-by=“id/$index”  通过什么跟踪<br>2.0版本  :key=“id/$index”  通过什么跟踪</p>
<p><strong> 循环一个object </strong></p>
<pre><code>&lt;div v-for=&quot;(key, val) in object&quot;&gt;
      {{ key }} {{ val }}
&lt;/div&gt;
</code></pre><p><strong> 事件 </strong></p>
<pre><code>@click.stop.prevent=“clickMe”           //阻止事件默认行为和冒泡
.capture          ==&gt;             添加事件侦听器时使用 capture 模式
.self              ==&gt;            只当事件在该元素本身触发时触发回调
</code></pre><p><strong> 按键修饰符 </strong></p>
<pre><code>@keyup.enter=&quot;submit&quot;        ==&gt;        回车
tab
delete
esc
space
up
down
left
right
</code></pre><p>1.0.8+： 支持单字母按键别名。</p>
<p>1.0.17+： 可以自定义按键别名：<br>// 可以使用 @keyup.f1<br>Vue.directive(‘on’).keyCodes.f1 = 112</p>
<h2 id="4-表单控件绑定"><a href="#4-表单控件绑定" class="headerlink" title="4.表单控件绑定"></a>4.表单控件绑定</h2><p><strong> v-model </strong></p>
<p><strong> 特殊属性 </strong></p>
<p>.lazy        默认v-model与input事件绑定，lazy变为与change事件绑定<br>number         将用户的输入转为 Number 类型（如果原值的转换结果为 NaN 则返回原值）</p>
<h2 id="5-transition-动画"><a href="#5-transition-动画" class="headerlink" title="5.transition 动画"></a>5.transition 动画</h2><pre><code>&lt;transition name=&quot;fade&quot;&gt;... &lt;/transition&gt;

.fade-enter,.fade-leave-active{
    opacity: 0;
}
.fade-enter-active,.fade-leave-active{
    transition: opacity .5s;
}
</code></pre><h2 id="6-组件"><a href="#6-组件" class="headerlink" title="6.组件"></a>6.组件</h2><pre><code>Vue.component(&apos;child&apos;, {
        // 声明 props
        props:[‘msg],    //实例化模板时，传进来的参数,先显式地用 props 选项声明 “prop”
        data: function () {
                return { a: 1 }                //必须return
        },
        // prop 可以用在模板内
        // 可以用 `this.msg` 设置
        template: &apos;&lt;span&gt;{{ msg }}&lt;/span&gt;&apos;
});
</code></pre><h3 id="组件之间的通信"><a href="#组件之间的通信" class="headerlink" title="组件之间的通信"></a>组件之间的通信</h3><p><strong> 父传子 : props传递 </strong></p>
<pre><code>//父组件中,绑定value的值到子组件的value属性
&lt;child :value=&quot;value&quot;&gt;&lt;/child&gt;

//子组件中，先props声明,再加入计算属性中
export default {
    props: [&apos;value&apos;],
    computed: {
        data (){
            return this.value;
        }
    }
}
</code></pre><p><strong> 子传父 : 子组件$emit(‘eventName’,data),父组件@eventName = “fn”接收事件,或者this.$on(‘eventName’,fn) </strong></p>
<pre><code>//父组件中,接受
&lt;child @eventName=&quot;fn&quot;&gt;&lt;/child&gt;

//子组件中,派发事件
this.$emit(‘eventName’,data);
</code></pre><p><strong> 非父子组件传递 </strong></p>
<pre><code>//创建一个空的vue实例hub，作为中转站,必须都注入到两个组件，并加入到计算属性，然后a组件用hub.$emit()派发事件，组件b用hub.$on()接收事件
</code></pre><p><strong> props验证 ：父传子时验证 </strong></p>
<pre><code>props: {
    // 基础类型检测 （`null` 意思是任何类型都可以）
    propA: Number,
    // 多种类型
    propB: [String, Number],
    // 必传且是字符串
    propC: {
          type: String,
          required: true
    },
    // 数字，有默认值
    propD: {
          type: Number,
          default: 100
    },
    // 数组／对象的默认值应当由一个工厂函数返回
    propE: {
          type: Object,
          default: function () {
            return { message: &apos;hello&apos; }
          }
    },
    // 自定义验证函数
    propF: {
          validator: function (value) {
            return value &gt; 10
          }
    }
  }
</code></pre><p><strong> 父子组件通信 </strong></p>
<p>子组件可以用 this.$parent 访问它的父组件。根实例的后代可以用 this.$root 访问它。父组件有一个数组 this.$children，包含它所有的子元素。</p>
<p>每个 Vue 实例都是一个事件触发器：</p>
<pre><code>使用 $on() 监听事件；

使用 $emit() 在它上面触发事件；

使用 $dispatch() 派发事件，事件沿着父链冒泡；

使用 $broadcast(‘data’,’hello’) 广播事件，事件向下传导给所有的后代。

通过events:{
    ‘data’: function(msg){
        console.log(msg)  ==  ‘hello’
    }
}

也可通过v-on:data=“***” 绑定自定义事件
</code></pre><p><strong> js中获取某个组件 </strong></p>
<pre><code>&lt;div id=&quot;parent&quot;&gt;
  &lt;user-profile v-ref:profile&gt;&lt;/user-profile&gt;
&lt;/div&gt;

var parent = new Vue({ el: &apos;#parent&apos; })
// 访问子组件
var child = parent.$refs.profile
</code></pre><p><strong> 动态组件 </strong></p>
<pre><code>new Vue({
      el: &apos;body&apos;,
      data: {
        currentView: &apos;home&apos;
      },
      components: {
        home: { /* ... */ },
        posts: { /* ... */ },
        archive: { /* ... */ }
      }
})
</code></pre><component :is="currentView"><br>  <!-- 组件在 vm.currentview 变化时改变 --><br></component>

<p><strong> slot分发内容 </strong></p>
<p>当子组件没有<slot>元素时，会将父组件的内容全部丢弃。<br>当子组件包含没有特性的<slot>元素时，父组件的内容会插到slot 所在的 DOM 位置并替换掉 slot 标签。<br>当子组件包含有特性的<slot>元素时，如<slot name="“header”"></slot>，父组件内具有slot=“header”属性的元素，会插到该<slot>中。父组件不包含slot属性的其他元素，将被插到子组件没有特性的<slot>元素中。</slot></slot></slot></slot></slot></p>
<h2 id="7-自定义指令"><a href="#7-自定义指令" class="headerlink" title="7.自定义指令"></a>7.自定义指令</h2><p><strong> 钩子函数： </strong></p>
<pre><code>·bind：只调用一次，在指令第一次绑定到元素上时调用。
·update： 在 bind 之后立即以初始值为参数第一次调用，之后每当绑定值变化时调用
·unbind：只调用一次，在指令从元素上解绑时调用。
</code></pre><p><strong> 钩子函数被赋予了以下参数： </strong></p>
<pre><code>el: 指令所绑定的元素，可以用来直接操作 DOM 。
binding: 一个对象，包含以下属性：
name: 指令名，不包括 v- 前缀。
value: 指令的绑定值， 例如： v-my-directive=&quot;1 + 1&quot;, value 的值是 2。
oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
expression: 绑定值的字符串形式。 例如 v-my-directive=&quot;1 + 1&quot; ， expression 的值是 &quot;1 + 1&quot;。
arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 &quot;foo&quot;。
modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。
vnode: Vue 编译生成的虚拟节点，查阅 VNode API 了解更多详情。
oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。


Vue.directive(&apos;my-directive&apos;, {
      params: [&apos;a&apos;],        //参数
      deep: true,            //指令绑定在对象上，对象属性修改时，触发update
      bind: function () {
        // 准备工作
        // 例如，添加事件处理器或只需要运行一次的高耗任务
      },
      update: function (newValue, oldValue) {
        // 值更新时的工作
        // 也会以初始值为参数调用一次

        //这里可以通过newValue取到指令属性的值，如果属性是字符串不是绑定的数据，要加.literal修饰。

           console.log(this.params.a)        ==&gt;  ‘abc’

      },
      unbind: function () {
        // 清理工作
        // 例如，删除 bind() 添加的事件监听器
      }
})

HTML中使用加v-前缀      &lt;div v-my-directive=“someValue” a=“abc”&gt;&lt;/div&gt;
</code></pre><h2 id="8-过滤器"><a href="#8-过滤器" class="headerlink" title="8.过滤器"></a>8.过滤器</h2><p><strong> 新建过滤器 </strong></p>
<pre><code>Vue.filter(&apos;reverse&apos;, function (value) {
  return value.split(&apos;&apos;).reverse().join(&apos;&apos;)
})

&lt;span v-text=&quot;message | reverse”&gt;&lt;/span&gt;
</code></pre><p><strong> 多参数过滤器 </strong></p>
<pre><code>Vue.filter(&apos;wrap&apos;, function (value, begin, end) {
  return begin + value + end
})

&lt;span v-text=&quot;message | wrap &apos;before&apos; ‘after&apos;&quot;&gt;&lt;/span&gt;
</code></pre><h2 id="9-混合mixin"><a href="#9-混合mixin" class="headerlink" title="9.混合mixin"></a>9.混合mixin</h2><pre><code>// 定义一个混合对象
var myMixin = {
      created: function () {
        this.hello()
      },
      methods: {
        hello: function () {
              console.log(&apos;hello from mixin!&apos;)
        }
      }
}

// 定义一个组件，使用这个混合对象
var Component = Vue.extend({
      mixins: [myMixin]
})

var component = new Component() // -&gt; &quot;hello from mixin!”
</code></pre><p>值为对象的选项，如 methods, components 和 directives 将合并到同一个对象内。如果键冲突则组件的选项优先。</p>
<p>————————————————————————————</p>
<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><p><strong> Vuex 是一个专门为 Vue.js 应用设计的 状态管理模型 + 库。 </strong></p>
<p><strong>  使用:  cnpm install vuex - -save-dev  </strong></p>
<h2 id="创建vuex实例："><a href="#创建vuex实例：" class="headerlink" title="创建vuex实例："></a>创建vuex实例：</h2><pre><code>//store.js

import Vue from &apos;vue&apos;
import Vuex from &apos;vuex&apos;
Vue.use(Vuex)

const store = new Vuex.Store({
      state: {    //存储数据
        count: 0
      },
      mutations: {    //修改数据
        increment (state) {
              state.count++
        }
      }
})

export default store  //暴露出去
</code></pre><p><strong> App.vue页面可以通过 import store from ‘./store.js’    引入 </strong></p>
<p><strong> 然后vue根实例可以通过 store : store 来注入store实例（//: store 可省略）  </strong></p>
<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p><strong> 各个组件中引用state数据，应该放在computed中，通过this.$store.state.–获取。注意：务必要放在computed中获取数据 </strong></p>
<h2 id="mapState工具"><a href="#mapState工具" class="headerlink" title="mapState工具"></a>mapState工具</h2><p>当一个组件要使用多个state数据时，可以用vuex的mapState工具：</p>
<pre><code>//如：state中有这几个数据

{
    name : &apos;拉不拉卡&apos;,
      age : 23,
     desc : ‘用来测试的’
 }

import {mapState} from ‘vuex’     //对象的解构赋值

//组件的computed ：

mapState({
    name : ‘name’,
    age : ‘age’,
    desc (){
     return ‘我叫’ +  this.$store.state.name+ ‘描述’ + this.$store.state.desc
      }
})
</code></pre><p><strong> 注意： </strong><br>mapState工具使用时，可以是[],也可以是{},当映射到store中的state的字段名，跟mapState中的字段名一样时，用[],mapState([‘name’]),相当于mapState({ name: ‘name’})；当不一致时，使用{},mapState({myName: ‘name’});</p>
<p><strong> mapState,mapGetters,mapActions 使用方式一样 </strong></p>
<h2 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h2><p>store实例中可以定义getters函数，来获取或者修改state数据。接收 state 作为第一个参数</p>
<pre><code>getters: {
    doneTodos: state =&gt; {
          return state.todos.filter(todo =&gt; todo.done)
    }
  }
</code></pre><p><strong> 子组件中也是通过computed使用getters： </strong></p>
<pre><code>return this.$store.getters.doneTodos
</code></pre><h2 id="mutation-修改state的数据-gt-同步操作"><a href="#mutation-修改state的数据-gt-同步操作" class="headerlink" title="mutation 修改state的数据 =&gt; 同步操作"></a>mutation 修改state的数据 =&gt; 同步操作</h2><p>接受状态(state) 作为第一个参数。可以传递多个参数payload为Object</p>
<pre><code>mutations: {
    increment (state,payload) {
          // 改变 state
         state.count += payload.amount
    }
  }

//子组件调用：
this.$store.commit(‘increment’)

//当传递多个参数时：
this.$store.commit(‘increment&apos;, {
      amount: 10
})

//或者用对象风格的Commit
this.$store.commit({
      type: &apos;increment&apos;,
      amount: 10
})
</code></pre><h2 id="action-gt-异步操作"><a href="#action-gt-异步操作" class="headerlink" title="action =&gt;  异步操作"></a>action =&gt;  异步操作</h2><p>action 和 mutation 类似，区别在于：</p>
<p>action 不改变状态，只提交(commit) mutation。<br>action 可以包含任意异步操作。</p>
<pre><code>const store = new Vuex.Store({
      state: {
           count: 0
      },
      mutations: {
        increment (state) {
              state.count++
        }
      },
      actions: {
        increment (context) {
              context.commit(&apos;increment&apos;)
        }
      }
})


//第一个参数context为上下文对象store，可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 访问 state 和 getters。

//action可以写成对象解构赋值的形式：
actions: {
      increment ({ commit }) {
        commit(&apos;increment&apos;)
      }
}
</code></pre><p><strong> 触发action </strong></p>
<p>使用 store.dispatch 方法触发 action。</p>
<p><strong> this.$store.dispatch(‘increment’) </strong></p>
<p>action 同样支持 payload 格式和对象风格的 dispatch：</p>
<pre><code>// dispatch 传入 payload
store.dispatch(&apos;incrementAsync&apos;, {
      amount: 10
})

// dispatch 传入一个对象
store.dispatch({
      type: &apos;incrementAsync&apos;,
      amount: 10
})
</code></pre><p><strong> 组合多个action </strong></p>
<p>由于action可以执行异步操作，而store.dispatch 返回『action 回调函数被触发后的返回值』，所以可以在 action 中返回一个 Promise 对象。</p>
<pre><code>actions: {
      actionA ({ commit }) {
        return new Promise((resolve, reject) =&gt; {
              setTimeout(() =&gt; {
                commit(&apos;someMutation&apos;)
                resolve()
              }, 1000)
        })
      }
}
</code></pre><p>现在你可以这么做：</p>
<pre><code>store.dispatch(&apos;actionA&apos;).then(() =&gt; {
      // ...
})
</code></pre><p>然后在另一个 action ：</p>
<pre><code>actions: {
      // ...
      actionB ({ dispatch, commit }) {
        return dispatch(&apos;actionA&apos;).then(() =&gt; {
              commit(&apos;someOtherMutation&apos;)
        })
      }
  }
</code></pre><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><p>Vuex 允许我们把 store 分 module（模块）。每一个模块包含各自的状态、mutation、action 和 getter，甚至是嵌套模块， 如下就是它的组织方式：</p>
<pre><code>const moduleA = {
      state: { ... },
      mutations: { ... },
      actions: { ... },
      getters: { ... }
}

const moduleB = {
      state: { ... },
      mutations: { ... },
      actions: { ... }
}

const store = new Vuex.Store({
      modules: {
        a: moduleA,
        b: moduleB
      }
})

store.state.a // -&gt; moduleA&apos;s state
store.state.b // -&gt; moduleB&apos;s state

//组件中使用
this.$store.state.a.**
</code></pre><p>模块的 mutations 和 getters方法第一个接收参数是模块的本地状态。</p>
<p>模块的 actions 中，context.state 暴露的是本地状态， context.rootState暴露的才是根状态。</p>
<p>模块的 getters 内，根状态也会作为第三个参数暴露。</p>
<p>————————————————————————</p>
<h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><p><strong> cnpm install vue-router - - save-dev </strong></p>
<pre><code>//main.js
import Vue from &apos;vue&apos;
import App from &apos;./App&apos;
import VueRouter from &apos;vue-router&apos;
import Page1 from &apos;./components/page1&apos;
import Page2 from &apos;./components/page2&apos;

Vue.use(VueRouter)

const routes = [
      { path: ‘/page1’, component: Page1 },
      { path: &apos;/page2&apos;, component: Page2 }
]

const router = new VueRouter({
    mode: &apos;history&apos;,    //h5模式，url没有/#/,还有一种hash模式就是/#/
    base: __dirname,    //双下划线
      routes
})

new Vue({
      router,
      el: &apos;#app&apos;,
      render: h =&gt; h(App)
}).$mount(&apos;#app&apos;)
</code></pre><p><strong> 跳转：&lt;router-link :to=“{name:’page1’}”&gt;点击 </strong></p>
<p><router-link>的参数：exact:严谨模式;append:在URL后继续追加</router-link></p>
<p><strong> 传递参数：&lt;router-link :to=“{name:’page1’, params: {id : 1}}”&gt;点击,会跳转到name=”page1”的component,可以通过$route.params.id获取参数id的值 </strong></p>
<p><strong> 上面代码等同于 this.$router.push({name: ‘page1’, params: { id : 1 }}) </strong></p>
<p><strong> 获取URL路由参数，比如path:’/page/:id’,可用$route.params.id获取 </strong></p>
<p><strong> 支持正则匹配：path: ‘page/:id(\d+)’ </strong></p>
<p><strong> 手动跳转：this.$router.push(‘/bar’) </strong></p>
<p><strong> 定义404页面 </strong></p>
<pre><code>const Page404 = {
    template: `
        &lt;h1&gt;error 页面走丢了&lt;/h1&gt;
    `
}
//routes 一定要放在routes的最后一个
{
    path: &apos;*&apos;,
    component: Page404
}
</code></pre><p><strong> 路由钩子函数 </strong></p>
<pre><code>//routes
{
    path: &apos;/foo&apos;,
    component: Foo,
    beforeEnter(to, from, next) =&gt;{
        next();  //接着执行，打断为next(false)
    },
    beforeLeave(to, from, next) =&gt;{
        next();  //接着执行，打断为next(false)
    }
}

//组件中
{
    template: &apos;&apos;,
    beforeRouteEnter(to, from, next) =&gt;{
        next();  //接着执行，打断为next(false)
    },
    beforeRouteLeave(to, from, next) =&gt;{
        next();  //接着执行，打断为next(false)
    }
}
</code></pre><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p><a href="https://github.com/ruanyf/webpack-demos#demo01-entry-file-source" target="_blank" rel="external">例子</a></p>
<pre><code>全局安装webpack/webpack-dev-server
cnpm i -g webpack webpack-dev-server
cd 到根目录下
cnpm init      //初始化package.json
cnpm  install webpack  webpack-dev-server —save-dev
//css使用style-loader、css-loader
cnpm install css-loader style-loader --save-dev
//js使用babel和es6新特性
cnpm install babel-loader babel-core babel-preset-es2015 --save-dev

  entry: &apos;entry.js&apos;,    //入口文件
  output: {
      path: __dirname,        //打包文件的存放位置
      filename: &apos;bundle.js&apos;    //打包的的文件名为bundle.js
  },
  devtool: &apos;source-map&apos;,        //使用source-map调试工具，debugger调试
module: {
    //加载器配置
    loaders: [
        //.css 文件使用 style-loader 和 css-loader 来处理
        { test: /\.css$/, loader: &apos;style-loader!css-loader&apos; },

        //.js 文件使用 babel-loader 来编译处理
        { test: /\.js$/, loader: &apos;babel-loader&apos; },

        //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理
        { test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;},

        //图片文件使用 url-loader 来处理，小于8kb的直接转为base64
        { test: /\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos;}
    ]
},
resolve: {
    extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.css&apos;, &apos;jsx&apos;]    //自动补全识别后缀
}
</code></pre><p>根据需要，安装所需要的包</p>
<p><strong> 使用jQuery </strong></p>
<pre><code>plugins:[
    new webpack.ProvidePlugin({
          $:&quot;jquery&quot;,
          jQuery:&quot;jquery&quot;,
          &quot;window.jQuery&quot;:&quot;jquery&quot;
    })
  ]
</code></pre><p><strong> 运行 ： webpack-dev-server –hot –inline </strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/02/17/vue/" data-id="cj358x9qd0002k0fytvphvnwa" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue-router/">vue-router</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vuex/">vuex</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/">webpack</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/02/16/hello-world/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Hello World
        
      </div>
    </a>
  
  
    <a href="/2017/02/17/es6/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">es6</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue-router/">vue-router</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vuex/">vuex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/es6/" style="font-size: 10px;">es6</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/vue-router/" style="font-size: 10px;">vue-router</a> <a href="/tags/vuex/" style="font-size: 10px;">vuex</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/26/http-timeout/">http&amp;timeout</a>
          </li>
        
          <li>
            <a href="/2017/04/21/angular/">angular</a>
          </li>
        
          <li>
            <a href="/2017/02/17/es6/">es6</a>
          </li>
        
          <li>
            <a href="/2017/02/17/vue/">vue</a>
          </li>
        
          <li>
            <a href="/2017/02/16/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 苏吉星<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>