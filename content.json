{"meta":{"title":"Welcome to 拉不拉卡's blog","subtitle":null,"description":"知识就是不断积累的过程","author":"苏吉星","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Ruby-Active-View","slug":"Ruby-Active-View","date":"2017-05-26T02:50:10.000Z","updated":"2017-05-26T03:10:49.000Z","comments":true,"path":"2017/05/26/Ruby-Active-View/","link":"","permalink":"http://yoursite.com/2017/05/26/Ruby-Active-View/","excerpt":"&lt;% %&gt;没有返回值，&lt;%= %&gt;输出结果","text":"&lt;% %&gt;没有返回值，&lt;%= %&gt;输出结果 局部视图 &lt;%= render “shared/menu” %&gt; //意思是会渲染app/views/shared/_menu.html.erb的文件 &lt;%= render partial: “product” , locals: {product: @product} %&gt; //在_product.html.erb中，可以使用本地变量product表示@product //as选项可以为本地变量指定一个名字 link_to &lt;%= link_to ‘名字’ , welcome_hello_path , :class =&gt; &apos;link&apos; , :style =&gt; “font-size:30px;&quot; %&gt; //welcome_hello_path的意思是，路由变成welcome/hello time #转换时间格式 time.strftime(“%Y-%m-%d&quot;) 布局 &lt;%= yield %&gt; # yield会声明一个区域，渲染的视图将会插到这里。 视图中可以表明多个区域：带参数的yield &lt;%= yield :widget %&gt; 视图中用 content_for 将下面内容插到指定的yield区域中 &lt;% content_for :widget do %&gt; &lt;%= render partial: &quot;home/widget/tags&quot;, locals: {ptags: @ptags} %&gt; &lt;% end %&gt; Helper image_tag &lt;%= image_tag &quot;a1.jpg&quot; %&gt; // app/assets/images/ javascript_include_tag javascript_include_tag:default //引入app/assets/Javascripts文件夹下application.js javascript_include_tag:all // 引入app/assets/Javascripts文件夹下所有的js文件 创建rails应用mkdir 文件夹名 cd 当前文件夹下 rails new demo - -skip-test-unit //创建项目 cd 当前文件夹下 bundle install //简写 bundle rails s 启动服务 新建controller rails g controller controller_name 配置路由，新建对应的views页面 get “welcome/hello” =&gt; “welcome#hello” //当路由变为左侧时，渲染右侧view页面，执行右侧对象controller里的方法 路由设置首页 root :to =&gt; “welcome#index” 建立数据库 rake db:create 删除数据库 rale db:drop 创建表 model名单数，生成的controller是复数 rails g scaffold person name:string bio:text birthday:date //scaffold创建一系列文件，model只创建modal 删除表 rails d scaffold person migrate rake db:migrate rails操作数据库Person.where( :name =&gt; ‘苏苏’ ) //返回数组 Person.find(2) //查找主键是2 .errors.full_messages //返回验证失败的原因，成功则返回空数组 RESTful应用 config/routes.rb加入以下一行程式 resources :events //会创建4个命名路由，对应7个Actions //运行 bin/rake routes会列出已经定义的路由规则 //使用&lt;%= link_to ‘Edit’ edit_event_path(event) %&gt; Ruby 语法 打印： puts “#{}” 可以字符串插值，必须双引号，单引号的字符串不可以这样插值 数据类型： 整数：Integer 浮点数：Float 字符串：String 数字和字符串不能直接相加，必须使用to_s、to_i、to_f来手动转型。 区域变量：小写字母或者下划线开头 常量：大写字母开头 空值：nil，表示未定义状态、未设定值。 nil.nil? # true 注释： 单行：# 开头 多行：=begin This is a comment line =end 字符串Symbols,:开头 :this_is_a_symbol 阵列Array Hash 键值对，一般用Symbol作key config = { :foo =&gt; 123, :bar =&gt; 456 } 等同于 { foo : 123 , bar : 456 } 遍历Hash config.each do |key,value| puts “#{key} is #{value}” end 语句 if if 条件 执行语句 elsif 条件 执行语句 else 执行语句 end 三元运算同js 控制结构Case case name when “John” puts “hello John” when “Rose” puts “hello Rose” else puts “——” end 循环 while，loop，until，next and break 结尾都加end，break跳出循环，next跳出本次循环 真或假，只有false和nil是假，其他都为真 正则，使用=~ phone =~ /(\\d{3})-(\\d{4)-(\\d{4})/ 方法Methods 使用def开头，end结尾定义一个方法 类 class定义，类名必须大写 @实例变量，@@类变量，只能在类别内部使用，外部无法获取。$全局变量 &lt; 代表继承 Module Module可以定义一些方法，然后先require当前module，然后在class中通过include引用当前创建的module，这个动作叫做Mixin","categories":[],"tags":[]},{"title":"http&timeout","slug":"http-timeout","date":"2017-05-26T02:43:28.000Z","updated":"2017-05-26T02:45:29.000Z","comments":true,"path":"2017/05/26/http-timeout/","link":"","permalink":"http://yoursite.com/2017/05/26/http-timeout/","excerpt":"angular、vue的缓存和http拦截1.angular 解决缓存问题 ·模板文件加上版本参数或者时间戳参数 $routeProvider .when(&apos;/Book/:bookId/ch/&apos;, { templateUrl: &apos;chapter.html&apos; + &apos;?datestamp=&apos; + (new Date()).getTime(), controller: &apos;ChapterController&apos; }); ·禁止模板缓存 app.run(function($rootScope, $templateCache) { $rootScope.$on(&apos;$routeChangeStart&apos;, function(event, next, current) { if (typeof(current) !== &apos;undefined&apos;){ $templateCache.remove(current.templateUrl); } }); });","text":"angular、vue的缓存和http拦截1.angular 解决缓存问题 ·模板文件加上版本参数或者时间戳参数 $routeProvider .when(&apos;/Book/:bookId/ch/&apos;, { templateUrl: &apos;chapter.html&apos; + &apos;?datestamp=&apos; + (new Date()).getTime(), controller: &apos;ChapterController&apos; }); ·禁止模板缓存 app.run(function($rootScope, $templateCache) { $rootScope.$on(&apos;$routeChangeStart&apos;, function(event, next, current) { if (typeof(current) !== &apos;undefined&apos;){ $templateCache.remove(current.templateUrl); } }); }); 2、http全局拦截 ·vue /******************拦截器设置请参考这部分(开始)******************/ Vue.http.interceptors.push((request, next) =&gt;{ //登录成功后将后台返回的TOKEN在本地存下来,每次请求从sessionStorage中拿到存储的TOKEN值 let TOKEN=sessionStorage.getItem(&apos;STORAGE_TOKEN&apos;); if(TOKEN){ //如果请求时TOKEN存在,就为每次请求的headers中设置好TOKEN,后台根据headers中的TOKEN判断是否放行 request.headers.set(&apos;TOKEN&apos;,TOKEN); } next((response) =&gt; { return response; }); }); /******************拦截器设置请参考这部分(结束)******************/ ·angular app.factory(&apos;myInterceptor&apos;, [&apos;$log&apos;,&apos;$q&apos;, function($log, $q){ //$log.debug(&apos;&apos;); console.log(&apos;进入拦截器&apos;); var myInterceptor = { request: function(config){ //此处可以判断token，session等，设置请求头headers //config.headers[&apos;x-session-token&apos;] = SessionService.token; if(false){ //假设token不存在 return $q.reject(config); }else{ return $q.resolve(config); } return config; }, response: function(response){ if(true){ //假设响应成功 console.log(&apos;response success&apos;); return response; }else{ return {} } } }; return myInterceptor; }]) app.config([&apos;$httpProvider&apos;, function($httpProvider){ $httpProvider.interceptors.push(&apos;myInterceptor&apos;); }]) 3、超时机制 ·vue（vue-resource） Vue.http.interceptors.push((request, next) =&gt; { let timeout; // 如果某个请求设置了_timeout,那么超过该时间，会终端该（abort）请求,并执行请求设置的钩子函数onTimeout方法，不会执行then方法。 if (request._timeout) { timeout = setTimeout(() =&gt; { //自定义响应体 status:408,statustext:&quot;请求超时&quot;，并返回给下下边的next next(request.respondWith(request.body, { status: 408, statusText: &apos;请求超时&apos; })); }, request._timeout); } next((response) =&gt; { clearTimeout(timeout); return response; }) }); //页面请求 this.$http.get(`/repairs`,{ params:{name:&apos;Bob&apos;}, _timeout:100,//设置超时时间 }).then((response)=&gt;{ },(err)=&gt;{ console.log(err.status);//如果超时，此处输出408 }); ·angular $http( { method: &apos;get&apos;, timeout: 5000 } ).success(fn);","categories":[],"tags":[]},{"title":"angular","slug":"angular","date":"2017-04-21T02:28:34.000Z","updated":"2017-04-26T08:05:21.000Z","comments":true,"path":"2017/04/21/angular/","link":"","permalink":"http://yoursite.com/2017/04/21/angular/","excerpt":"angular脏检查 $scope.apply(function(){}) 触发脏检查，检查scope中的每个属性是否发生变化 定义服务 $provide//module第二个参数是一来的模块，第三个参数是个方法，用来定义服务 var app = angular.module(&apos;myApp&apos;, [], function($provide){ //定义服务 $provide.provider = function(){ this.$get = function(){ return &apos;任何数据&apos; } } }); //也可以这样定义服务 app.provider = function(){ this.$get = function(){ return &apos;任何数据&apos; } } //使用：注入使用，和$scope一样","text":"angular脏检查 $scope.apply(function(){}) 触发脏检查，检查scope中的每个属性是否发生变化 定义服务 $provide//module第二个参数是一来的模块，第三个参数是个方法，用来定义服务 var app = angular.module(&apos;myApp&apos;, [], function($provide){ //定义服务 $provide.provider = function(){ this.$get = function(){ return &apos;任何数据&apos; } } }); //也可以这样定义服务 app.provider = function(){ this.$get = function(){ return &apos;任何数据&apos; } } //使用：注入使用，和$scope一样 自定义工厂 factory$provide.factory(&apos;factoryName&apos;, function(){ return &apos;任意类型数据&apos;; }); //也可以这样定义工厂 app.factory(&apos;factoryName&apos;, function(){ return &apos;任意类型数据&apos;; }); //使用：注入使用，和$scope一样 自定义服务 service$provide.service(&apos;serviceName&apos;, function(){ return &apos;必须是引用类型的数据,function、[]或者{}&apos;; }); //也可以这样自定义服务 app.service(&apos;serviceName&apos;, function(){ return &apos;必须是引用类型的数据,function、[]或者{}&apos;; }); //使用：注入使用，和$scope一样 过滤器 filter//html中使用 {{ data | filter : 'name'}} {{ data : filter : {name: 'susu'} }} //js中使用 $filter(&apos;json&apos;)($scope.data); //格式化json数据，调试用 内置指令 ng-repeat $index //当前索引 $first //是否为第一个元素，布尔型 $middle //是否为非头非尾元素，布尔型 $last //是否为尾元素，布尔型 //奇数偶数class ng-class-even //偶数 ng-class-odd //奇数 ng-include ng-include=&quot;&apos;other.html&apos;&quot; //一定用单引号引起来 //或者 ng-include src=&quot;&apos;other.html&apos;&quot; ng-style //两种写法 //小驼峰，属性名不用加引号 ng-style=&quot;{backgroundColor: &apos;#afa&apos;}&quot; //css写法，加引号 ng-style=&quot;&apos;backgound-color&apos;: &apos;#afa&apos;&quot; 内置事件 ng-click //获取触发元素 ng-click=&quot;clickMe($event)&quot; $scope.clickMe = function(event){ console.log(event.target); //触发元素 angular.element(event.target); //变为JQuery元素 } 自定义指令app.directive(&apos;myDirective&apos;, function(){ return { restrict: &apos;E&apos;, //E,C,A,M template: &apos;&lt;div&gt;div &lt;span ng-transclude&gt;&lt;/span&gt;&lt;/div&gt;&apos;, replace: true, transclude: true, //为true时，会把原始标签的内容放到template中带有ng-transclude的元素中， compile: function(tElement, tAttrs, transclude){ //compile函数返回的就是postLink函数，也可以写成对象形式的preLink和postLink函数，下面的link函数不生效 //用来修改 return { pre: function(){}, post: function(){} } }, scope: {}/true/false, /* * scope详解 * 当scope为true时，创建独立作用域，但可以共用父级作用域的数据； 当scope为{}时，创建独立作用域，不可使用父级作用域数据 */ scope: { name: &apos;&amp;value&apos;, //把父作用域的name属性包装成一个函数，&lt;my-directive value=&quot;name&quot;&gt;&lt;/my-directive&gt;,当前指令中controller和link函数中，可以通过$scope.name()获取父controller的name属性 name: &apos;=value&apos;, //双向绑定父作用域的name属性和当前指令作用域中的name属性，&lt;my-directive value=&quot;name&quot;&gt;&lt;/my-directive&gt;，当前指令中controller和link函数中，可以通过$scope.name获取和修改父controller的name属性 name: &apos;@value&apos;, //单向绑定父作用域的name属性和当前指令作用域中的name属性，&lt;my-directive value=&quot;{{name}}&quot;&gt;&lt;/my-directive&gt;，当前指令中controller和link函数中，可以通过$scope.name获取父controller的name属性。 注意，传递过来的数据类型都是变为String，所以要通过JSON.parse()转化数据类型 } controller: function($scope){ //当前指令的controller }, require: &apos;^myDirective&apos;, //注入其他指令,link函数第四个参数可接受该指令的controller,^意思是允许向父级查找 link: function(scope, iElement, iAttr[, iController]){ //第四个参数是当当前指令，require其他指令时，iController为require进来指令的controller //当compile函数返回postLink函数时，link函数不执行 } } }); module的几个常用服务 value/constant/run/config//name可以注入到controller中 app.value(&apos;name&apos;, &apos;susu&apos;); //content可以注入到anywhere app.constant(&apos;content&apos;, &apos;susu&apos;); //run 注入之后，用户操作页面之前执行 app.run(function(){}); 表单验证 input 属性 name //名字 ng-model //绑定数据 ng-required //是否必填 ng-minlength //最小长度 ng-maxlength //最大长度 ng-pattern //匹配模式“/^正则表达式&amp;/” ng-change //值变化时 select属性 ng-options //循环option，加在select上 ng-selected //表达式或布尔值，加载option上 &lt;select class=&quot;form-control&quot; ng-model=&quot;formData.city&quot; ng-options=&quot;{name: city.name, id: city.id} as city.name for city in cities&quot; ng-required=&quot;true&quot; id=&quot;city&quot;&gt; &lt;option value=&quot;&quot;&gt;--请选择--&lt;/option&gt; &lt;/select&gt; //controller中formData.city的值就是as前的格式，option中显示的字就是as后面字段的内容 输入验证提示信息 //提交按钮的状态，表单验证通过，可以提交，否则，disabled ng-disabled=&quot;formName.$invalid&quot; //formName.inputName.$error中的属性，验证通过为false，否则为true &lt;div class=&quot;error&quot; ng-show=“formName.inputName.$error.pattern”&gt;请输入5-10位的字母&lt;/div&gt; formName.inputName.$eror.pattern formName.inputName.$error.minlength formName.inputName.$error.maxlength formName.inputName.$error.required //验证失败，值为true，通过为false formName.inputName.$dirty //表单修改，值为true formName.inputName.$pristine //表单修改，值为false formName.inputName.$valid //表单输入内容合法，值为true formName.inputName.$invalid //表单输入内容合法，值为false //可以结合以上的属性，来控制表单输入提示信息，和表单验证 重置表单 //HTML &lt;button type=&quot;reset&quot; ng-click=&quot;reset()&quot;&gt;重置&lt;/button&gt; //controller $scope.reset = function(){ $scope.myForm.$setPristine(); //重置$dirty,class,$pristine } 自定义表单验证 //ngModel的属性 app.directive(&apos;even&apos;,function(){ return { require: &apos;ngModel&apos;, link: function(scope, tElement, tAttr, tController){ //$parsers,是view向model存储的数据，也就是表单输入的数据，即将存到model tController.$parsers.push(function(value){ console.log(value); if(value % 2 === 0){ //设置表单的错误验证，可以通过myForm.inputName.$error.even获取到 tController.$setValidity(&apos;even&apos;, true); }else{ tController.$setValidity(&apos;even&apos;, false); } //必须有return return value; }); //$formatters，是model向view传送的数据，就是从model中取出来，要展示在页面的数据 tController.$formatters.push(function(value){ //可以操作value，必须return return value; }); //$setViewValue,是当view发生了某件事情时，从view向model储存时调用，结合scope.$apply(fn) tElement.on(&apos;keyup&apos;, function(){ scope.$apply(function(){ tController.$setViewValue(tElement.html()); }); }); //$render，是当model变化时，通知view更新视图 tController.$render = function(){ tElement.html(tController.$modelValue); } //$viewValue 视图view里的值 //$modelValue model里的值 } } });","categories":[],"tags":[]},{"title":"es6","slug":"es6","date":"2017-02-17T08:41:44.000Z","updated":"2017-02-17T08:43:07.000Z","comments":true,"path":"2017/02/17/es6/","link":"","permalink":"http://yoursite.com/2017/02/17/es6/","excerpt":"ES61、let和const命令 let命令 let声明的变量，只在当前代码块中有效。——适合用于for循环等 没有声明提前，一定要先声明再使用。 const命令 const声明的常量，一旦声明，不可改变。跟let一样，先声明，后使用。如果const声明了一个数组或者对象，指向该类型数据的地址，该类型数据里的属性跟值是可以改变的，但是不能将一个新的对象或数组重新赋值，因为地址要改变了。 遍历数组、对象 for(let [key,value] of arr.entries() / Object.entries(obj)){} //数组用arr.entries(),对象用Object.entries(obj);","text":"ES61、let和const命令 let命令 let声明的变量，只在当前代码块中有效。——适合用于for循环等 没有声明提前，一定要先声明再使用。 const命令 const声明的常量，一旦声明，不可改变。跟let一样，先声明，后使用。如果const声明了一个数组或者对象，指向该类型数据的地址，该类型数据里的属性跟值是可以改变的，但是不能将一个新的对象或数组重新赋值，因为地址要改变了。 遍历数组、对象 for(let [key,value] of arr.entries() / Object.entries(obj)){} //数组用arr.entries(),对象用Object.entries(obj); 2、变量的解构赋值var [a, b, c] = [1, 2, 3]; //允许使用默认值： [x, y = &apos;b&apos;] = [&apos;a&apos;, undefined]; // x=&apos;a&apos;, y=‘b&apos; 只有当值全等于undefined时，默认值才生效 let [foo, [[bar], baz]] = [1, [[2], 3]]; foo // 1 bar // 2 baz // 3 var { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; foo // &quot;aaa&quot; bar // “bbb” 对象解构赋值 时，先从值中找见同名属性的值，赋值给当前属性。如果是下面这种情况，当前属性foo的值是变量baz，则赋值给当前变量baz，foo只是模式，不会被赋值。 var { foo: baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; baz // &quot;aaa&quot; foo // error: foo is not defined 用法： let { log, sin, cos } = Math; 字符串的解构赋值 let {length : len} = &apos;hello&apos;; len // 5 字符串被转换成了一个类似数组的对象，似数组的对象都有一个length属性。 用途： 1、交换变量的值 var x = 1; var y = 2; [x,y] = [y,x]; //x === 2 //y === 1 2、函数返回多个值 // 返回一个数组 function example() { return [1, 2, 3]; } var [a, b, c] = example(); // 返回一个对象 function example() { return { foo: 1, bar: 2 }; } var { foo, bar } = example(); 3、提取json数据 var jsonData = { id: 42, status: &quot;OK&quot;, data: [867, 5309] }; let { id, status, data: number } = jsonData; console.log(id, status, number); // 42, &quot;OK&quot;, [867, 5309] 4、遍历Map结构 var map = new Map(); map.set(&apos;first&apos;, &apos;hello&apos;); map.set(&apos;second&apos;, &apos;world&apos;); for (let [key, value] of map) { console.log(key + &quot; is &quot; + value); } // first is hello // second is world // 获取键名 for (let [key] of map) { // ... } // 获取键值 for (let [,value] of map) { // ... } 3、字符串的扩展 Unicode表示法 将码点放入大括号，就能正确解读该字符。 &quot;\\u{20BB7}&quot; // “𠮷” 字符串的遍历 for (let codePoint of &apos;foo&apos;) { console.log(codePoint) } // &quot;f&quot; // &quot;o&quot; // “o&quot; at() 返回制定位置的字符串，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符。 &apos;abc&apos;.at(0) // &quot;a&quot; &apos;𠮷&apos;.at(0) // “𠮷&quot; includes(), startsWith(), endsWith() includes() //返回布尔值，表示是否找到了参数字符串。 startsWith() //返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith() //返回布尔值，表示参数字符串是否在源字符串的尾部。 var s = &apos;Hello world!&apos;; s.startsWith(&apos;Hello&apos;) // true s.endsWith(&apos;!&apos;) // true s.includes(&apos;o&apos;) // true 可携带第二个参数，从表示开始查找的位置。endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 repeat() 复制该字符串n次 &apos;x&apos;.repeat(3) // &quot;xxx&quot; &apos;hello&apos;.repeat(2) // &quot;hellohello&quot; &apos;na&apos;.repeat(0) // “&quot; &apos;na&apos;.repeat(NaN) // “” 如果repeat的参数是字符串，则会先转换成数字。 &apos;na&apos;.repeat(&apos;na&apos;) // &quot;&quot; &apos;na&apos;.repeat(&apos;3&apos;) // “nanana&quot; 字符串补全 padStart() 头部补全，padEnd() 用于尾部补全。 &apos;x&apos;.padStart(5, &apos;ab&apos;) // &apos;ababx&apos; &apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos; &apos;x&apos;.padEnd(5, &apos;ab&apos;) // &apos;xabab&apos; &apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos; 模板字符串 反引号 ``中可以写多行字符串，${}中写js表达式 4、正则扩展var regex = new RegExp(&apos;xyz&apos;, &apos;i&apos;); // 等价于 var regex = /xyz/i; flags属性 flags属性，会返回正则表达式的修饰符。 // ES5的source属性 // 返回正则表达式的正文 /abc/ig.source // &quot;abc&quot; // ES6的flags属性 // 返回正则表达式的修饰符 /abc/ig.flags // ‘gi&apos; 5、Number扩展 Number.isFinite() 用来检查一个数值是否为有限的（finite）。 Number.isNaN() 用来检查一个值是否为NaN。 Number.parseInt(), Number.parseFloat() Number.isInteger() 用来判断一个值是否为整数。 6、Math扩展 Math.trunc() 方法用于去除一个数的小数部分，返回整数部分。 Math.sign() 方法用来判断一个数到底是正数、负数、还是零。它会返回五种值。 参数为正数，返回+1；参数为负数，返回-1；参数为0，返回0；参数为-0，返回-0;其他值，返回NaN。 Math.cbrt() 方法用于计算一个数的立方根。 7、Array扩展 Array.from() 将类数组、可遍历的对象转换成真正的数组。 Array.from(&apos;hello&apos;) // [&apos;h&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, ‘o&apos;] Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 Array.from([1, 2, 3], (x) =&gt; x * x) // [1, 4, 9] Array.of() 将一组值，转换为数组。 Array.of(3, 11, 8) // [3,11,8] Array.of(3) // [3] Array.of(3).length // 1 //区分Array Array() // [] Array(3) // [, , ,] Array(3, 11, 8) // [3, 11, 8] find()和findIndex() 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 [1, 5, 10, 15].find(function(value, index, arr) { return value &gt; 9;}) // 10 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 [1, 5, 10, 15].findIndex(function(value, index, arr) { return value &gt; 9; }) // 2 fill()方法使用给定值，填充一个数组。 [&apos;a&apos;, &apos;b&apos;, ‘c&apos;].fill(7) // [7, 7, 7] entries()，keys()和values() keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 includes() 返回布尔值，判断数组中是否包含制定值 [1, 2, 3].includes(2); // true [1, 2, 3].includes(4); // false 8、function扩展 函数的length属性，将返回没有指定默认值的参数个数。 合并数组： var arr1 = [&apos;a&apos;, &apos;b&apos;]; var arr2 = [&apos;c&apos;]; var arr3 = [&apos;d&apos;, &apos;e&apos;]; // ES6的合并数组 [...arr1, ...arr2, ...arr3] // [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos; ] 函数的name属性，返回该函数的函数名。 箭头函数 =&gt; 9、Object扩展 属性的简写 ES6允许在对象之中，只写属性名，不写属性值。这时，属性值等于属性名所代表的变量。 var foo = &apos;bar&apos;; var baz = {foo}; baz // {foo: &quot;bar&quot;} function f(x, y) { return {x, y}; } // 等同于 function f(x, y) { return {x: x, y: y}; } var birth = &apos;2000/01/01&apos;; var Person = { name: &apos;张三&apos;, //等同于birth: birth birth, // 等同于hello: function ()... hello() { console.log(&apos;我的名字是&apos;, this.name); } }; 对象的合并 Object.assign(target,obj1,obj2); // 将obj1和obj2的属性合并到target上面，如果有同名属性，后者覆盖target。 对象的遍历 for…in Object.keys(obj) 返回对象自身所有键的数组 Object.values(obj) 返回对象自身所有值的数组 Object.entries(obj) 返回对象自身所有键、值的数组 10、Symbol 生成独一无二的字符串var s1 = Symbol(‘foo’); var s3 = Symbol(‘foo’); var s2 = Symbol.for(“foo”); s1 === s2 true s1 === s3 false 原始类型，不能new， Symbol() 写法没有登记机制，所以每次调用都会返回一个不同的值。 Symbol.for() ，它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。 11、proxy get() get方法的两个参数分别是目标对象和所要访问的属性 var person = { name: &quot;张三&quot; }; var proxy = new Proxy(person, { get: function(target, property) { if (property in target) { return target[property]; } else { throw new ReferenceError(&quot;Property \\&quot;&quot; + property + &quot;\\&quot; does not exist.&quot;); } } }); proxy.name // &quot;张三&quot; proxy.age // 抛出一个错误 set() set方法用来拦截某个属性的赋值操作。三个参数分别是实例对象、修改的属性名、修改的属性值。 let validator = { set: function(obj, prop, value) { if (prop === &apos;age&apos;) { if (!Number.isInteger(value)) { throw new TypeError(&apos;The age is not an integer&apos;); } if (value &gt; 200) { throw new RangeError(&apos;The age seems invalid&apos;); } } // 对于age以外的属性，直接保存 obj[prop] = value; } }; let person = new Proxy({}, validator); person.age = 100; person.age // 100 person.age = &apos;young&apos; // 报错 person.age = 300 // 报错 12、set和map数据结构 new Set() 创建的值类似于数组，但是成员的值都是唯一的，没有重复的值。因此可以结合扩展运算符去除重复元素： // 去除数组的重复成员 [...new Set(array)] 通过new Set()创建的实例，拥有以下属性和方法： size : 返回Set实例的成员总数。 add(value) ：添加某个值，返回Set结构本身。 delete(value) ：删除某个值，返回一个布尔值，表示删除是否成功。 has(value) ：返回一个布尔值，表示该值是否为Set的成员。 clear() ：清除所有成员，没有返回值。 new Map() var m = new Map(); var o = {p: &apos;Hello World&apos;}; m.set(o, &apos;content&apos;) m.get(o) // &quot;content&quot; m.has(o) // true m.delete(o) // true m.has(o) // false 通过new Map()创建的实例，拥有以下属性和方法： size : 返回Map实例的成员总数 set(key, value) ： set方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。 get(key) ： get方法读取key对应的键值，如果找不到key，返回undefined。 has(key) ： has方法返回一个布尔值，表示某个键是否在Map数据结构中。 delete(key) ： delete方法删除某个键，返回true。如果删除失败，返回false。 clear() ： clear方法清除所有成员，没有返回值。 13、Promise对象三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败），promise实例立即调用，成功执行resolve(),可带参数，失败执行reject()，也可携带参数。promise实例的then()方法,两个参数都是function，第一个是捕捉成功时resolve的数据，第二个是捕捉失败时reject的数据。可接到传递的参数。 var promise1 = new Promise(function(resolve,reject){ console.log(11) resolve(&apos;aa&apos;); setTimeout(function(){ reject(new Error(&apos;error~~~~&apos;)); },1000); }); promise1.then(function(value){ console.log(value); return &apos;bb&apos;; }).then(function(value){ console.log(value); }); 14、Generator函数，异步操作，可以理解为状态机。函数返回可遍历的状态function* helloWorldGenerator() { yield &apos;hello&apos;; yield &apos;world&apos;; return &apos;ending&apos;; } var hw = helloWorldGenerator(); hw.next() // { value: &apos;hello&apos;, done: false } hw.next() // { value: &apos;world&apos;, done: false } hw.next() // { value: &apos;ending&apos;, done: true } hw.next() // { value: undefined, done: true } 调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象。执行next方法，开始执行Generator函数，知道碰到第一个yield，……….遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 next()的参数： yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。 15、async函数 async函数返回一个Promise对象。async函数内部return语句返回的值，会成为then方法回调函数的参数。 async function fn(){ await f1(); await f2(); return ‘aaa’ } fn().then(n =&gt; console.log(n));//‘aaa’","categories":[],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"vue","slug":"vue","date":"2017-02-17T07:05:41.000Z","updated":"2017-04-27T10:08:25.000Z","comments":true,"path":"2017/02/17/vue/","link":"","permalink":"http://yoursite.com/2017/02/17/vue/","excerpt":"Vue Atom使用vue install langage-vue 1.使用Vue脚手架新建项目//全局安装 vue-cli cnpm install -g vue-cli //创建一个基于 &quot;webpack&quot; 模板的新项目 vue init webpack my-project //安装依赖，走你 cd my-project //安装所需的模块 cnpm install cnpm run dev","text":"Vue Atom使用vue install langage-vue 1.使用Vue脚手架新建项目//全局安装 vue-cli cnpm install -g vue-cli //创建一个基于 &quot;webpack&quot; 模板的新项目 vue init webpack my-project //安装依赖，走你 cd my-project //安装所需的模块 cnpm install cnpm run dev （1）使用scss, cnpm install node-sass sass-loader scss-loader - -save-dev(save前面两个-),&lt;style lang=“scss” scoped&gt; scoped是局部作用域 (2) 安装出错 执行sudo rm -r -f ~/node_modules. ,重新install (3) 使用jquery 、vue-router ： cnpm install jquery —save-dev 2.创建Vue实例var vm = new Vue({ el: ‘#div’, data: { //数据 a: 1 }, methods: {}, //方法 watch:{}, //监听数据 created: function(){ //在实例创建后调用 }, computed:{ b: function(){ return this.a + 1 } } }); 访问该实例的一些钩子属性：vm.$datavm.$el… 当DOM更新后调用 this/vm.$nextTick(function () { console.log(this.$el.textContent) // =&gt; &apos;updated&apos; }) 3.Vue指令v-on:click=“clickMe” 等价于 @click=“clickMe” //点击事件 v-on:keyup.enter=“save” 等价于 @keyup.enter=“save” //按下回车键 v-bind:class=“{class1:true,class2:false}” ==&gt; class=“class1” v-bind:class=“[class1,class2]” ==&gt; class=“class1 class2” v-bind:style=“styleObject” ==&gt; :style=“styleObject” data: { styleObject: { color: &apos;red&apos;, fontSize: &apos;13px&apos; } } v-html=“xx” 循环 v-for=“item in items” $index是当前循环的索引v-for支持第二个参数作为当前项的索引1.0版本 track-by=“id/$index” 通过什么跟踪2.0版本 :key=“id/$index” 通过什么跟踪 循环一个object &lt;div v-for=&quot;(key, val) in object&quot;&gt; {{ key }} {{ val }} &lt;/div&gt; 事件 @click.stop.prevent=“clickMe” //阻止事件默认行为和冒泡 .capture ==&gt; 添加事件侦听器时使用 capture 模式 .self ==&gt; 只当事件在该元素本身触发时触发回调 按键修饰符 @keyup.enter=&quot;submit&quot; ==&gt; 回车 tab delete esc space up down left right 1.0.8+： 支持单字母按键别名。 1.0.17+： 可以自定义按键别名：// 可以使用 @keyup.f1Vue.directive(‘on’).keyCodes.f1 = 112 4.表单控件绑定 v-model 特殊属性 .lazy 默认v-model与input事件绑定，lazy变为与change事件绑定number 将用户的输入转为 Number 类型（如果原值的转换结果为 NaN 则返回原值） 5.transition 动画&lt;transition name=&quot;fade&quot;&gt;... &lt;/transition&gt; .fade-enter,.fade-leave-active{ opacity: 0; } .fade-enter-active,.fade-leave-active{ transition: opacity .5s; } 6.组件Vue.component(&apos;child&apos;, { // 声明 props props:[‘msg], //实例化模板时，传进来的参数,先显式地用 props 选项声明 “prop” data: function () { return { a: 1 } //必须return }, // prop 可以用在模板内 // 可以用 `this.msg` 设置 template: &apos;&lt;span&gt;{{ msg }}&lt;/span&gt;&apos; }); 组件之间的通信 父传子 : props传递 //父组件中,绑定value的值到子组件的value属性 &lt;child :value=&quot;value&quot;&gt;&lt;/child&gt; //子组件中，先props声明,再加入计算属性中 export default { props: [&apos;value&apos;], computed: { data (){ return this.value; } } } 子传父 : 子组件$emit(‘eventName’,data),父组件@eventName = “fn”接收事件,或者this.$on(‘eventName’,fn) //父组件中,接受 &lt;child @eventName=&quot;fn&quot;&gt;&lt;/child&gt; //子组件中,派发事件 this.$emit(‘eventName’,data); 非父子组件传递 //创建一个空的vue实例hub，作为中转站,必须都注入到两个组件，并加入到计算属性，然后a组件用hub.$emit()派发事件，组件b用hub.$on()接收事件 props验证 ：父传子时验证 props: { // 基础类型检测 （`null` 意思是任何类型都可以） propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: { type: String, required: true }, // 数字，有默认值 propD: { type: Number, default: 100 }, // 数组／对象的默认值应当由一个工厂函数返回 propE: { type: Object, default: function () { return { message: &apos;hello&apos; } } }, // 自定义验证函数 propF: { validator: function (value) { return value &gt; 10 } } } 父子组件通信 子组件可以用 this.$parent 访问它的父组件。根实例的后代可以用 this.$root 访问它。父组件有一个数组 this.$children，包含它所有的子元素。 每个 Vue 实例都是一个事件触发器： 使用 $on() 监听事件； 使用 $emit() 在它上面触发事件； 使用 $dispatch() 派发事件，事件沿着父链冒泡； 使用 $broadcast(‘data’,’hello’) 广播事件，事件向下传导给所有的后代。 通过events:{ ‘data’: function(msg){ console.log(msg) == ‘hello’ } } 也可通过v-on:data=“***” 绑定自定义事件 js中获取某个组件 &lt;div id=&quot;parent&quot;&gt; &lt;user-profile v-ref:profile&gt;&lt;/user-profile&gt; &lt;/div&gt; var parent = new Vue({ el: &apos;#parent&apos; }) // 访问子组件 var child = parent.$refs.profile 动态组件 new Vue({ el: &apos;body&apos;, data: { currentView: &apos;home&apos; }, components: { home: { /* ... */ }, posts: { /* ... */ }, archive: { /* ... */ } } }) slot分发内容 当子组件没有元素时，会将父组件的内容全部丢弃。当子组件包含没有特性的元素时，父组件的内容会插到slot 所在的 DOM 位置并替换掉 slot 标签。当子组件包含有特性的元素时，如，父组件内具有slot=“header”属性的元素，会插到该中。父组件不包含slot属性的其他元素，将被插到子组件没有特性的元素中。 7.自定义指令 钩子函数： ·bind：只调用一次，在指令第一次绑定到元素上时调用。 ·update： 在 bind 之后立即以初始值为参数第一次调用，之后每当绑定值变化时调用 ·unbind：只调用一次，在指令从元素上解绑时调用。 钩子函数被赋予了以下参数： el: 指令所绑定的元素，可以用来直接操作 DOM 。 binding: 一个对象，包含以下属性： name: 指令名，不包括 v- 前缀。 value: 指令的绑定值， 例如： v-my-directive=&quot;1 + 1&quot;, value 的值是 2。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression: 绑定值的字符串形式。 例如 v-my-directive=&quot;1 + 1&quot; ， expression 的值是 &quot;1 + 1&quot;。 arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 &quot;foo&quot;。 modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点，查阅 VNode API 了解更多详情。 oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 Vue.directive(&apos;my-directive&apos;, { params: [&apos;a&apos;], //参数 deep: true, //指令绑定在对象上，对象属性修改时，触发update bind: function () { // 准备工作 // 例如，添加事件处理器或只需要运行一次的高耗任务 }, update: function (newValue, oldValue) { // 值更新时的工作 // 也会以初始值为参数调用一次 //这里可以通过newValue取到指令属性的值，如果属性是字符串不是绑定的数据，要加.literal修饰。 console.log(this.params.a) ==&gt; ‘abc’ }, unbind: function () { // 清理工作 // 例如，删除 bind() 添加的事件监听器 } }) HTML中使用加v-前缀 &lt;div v-my-directive=“someValue” a=“abc”&gt;&lt;/div&gt; 8.过滤器 新建过滤器 Vue.filter(&apos;reverse&apos;, function (value) { return value.split(&apos;&apos;).reverse().join(&apos;&apos;) }) &lt;span v-text=&quot;message | reverse”&gt;&lt;/span&gt; 多参数过滤器 Vue.filter(&apos;wrap&apos;, function (value, begin, end) { return begin + value + end }) &lt;span v-text=&quot;message | wrap &apos;before&apos; ‘after&apos;&quot;&gt;&lt;/span&gt; 9.混合mixin// 定义一个混合对象 var myMixin = { created: function () { this.hello() }, methods: { hello: function () { console.log(&apos;hello from mixin!&apos;) } } } // 定义一个组件，使用这个混合对象 var Component = Vue.extend({ mixins: [myMixin] }) var component = new Component() // -&gt; &quot;hello from mixin!” 值为对象的选项，如 methods, components 和 directives 将合并到同一个对象内。如果键冲突则组件的选项优先。 ———————————————————————————— vuex Vuex 是一个专门为 Vue.js 应用设计的 状态管理模型 + 库。 使用: cnpm install vuex - -save-dev 创建vuex实例：//store.js import Vue from &apos;vue&apos; import Vuex from &apos;vuex&apos; Vue.use(Vuex) const store = new Vuex.Store({ state: { //存储数据 count: 0 }, mutations: { //修改数据 increment (state) { state.count++ } } }) export default store //暴露出去 App.vue页面可以通过 import store from ‘./store.js’ 引入 然后vue根实例可以通过 store : store 来注入store实例（//: store 可省略） state 各个组件中引用state数据，应该放在computed中，通过this.$store.state.–获取。注意：务必要放在computed中获取数据 mapState工具当一个组件要使用多个state数据时，可以用vuex的mapState工具： //如：state中有这几个数据 { name : &apos;拉不拉卡&apos;, age : 23, desc : ‘用来测试的’ } import {mapState} from ‘vuex’ //对象的解构赋值 //组件的computed ： mapState({ name : ‘name’, age : ‘age’, desc (){ return ‘我叫’ + this.$store.state.name+ ‘描述’ + this.$store.state.desc } }) 注意： mapState工具使用时，可以是[],也可以是{},当映射到store中的state的字段名，跟mapState中的字段名一样时，用[],mapState([‘name’]),相当于mapState({ name: ‘name’})；当不一致时，使用{},mapState({myName: ‘name’}); mapState,mapGetters,mapActions 使用方式一样 gettersstore实例中可以定义getters函数，来获取或者修改state数据。接收 state 作为第一个参数 getters: { doneTodos: state =&gt; { return state.todos.filter(todo =&gt; todo.done) } } 子组件中也是通过computed使用getters： return this.$store.getters.doneTodos mutation 修改state的数据 =&gt; 同步操作接受状态(state) 作为第一个参数。可以传递多个参数payload为Object mutations: { increment (state,payload) { // 改变 state state.count += payload.amount } } //子组件调用： this.$store.commit(‘increment’) //当传递多个参数时： this.$store.commit(‘increment&apos;, { amount: 10 }) //或者用对象风格的Commit this.$store.commit({ type: &apos;increment&apos;, amount: 10 }) action =&gt; 异步操作action 和 mutation 类似，区别在于： action 不改变状态，只提交(commit) mutation。action 可以包含任意异步操作。 const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit(&apos;increment&apos;) } } }) //第一个参数context为上下文对象store，可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 访问 state 和 getters。 //action可以写成对象解构赋值的形式： actions: { increment ({ commit }) { commit(&apos;increment&apos;) } } 触发action 使用 store.dispatch 方法触发 action。 this.$store.dispatch(‘increment’) action 同样支持 payload 格式和对象风格的 dispatch： // dispatch 传入 payload store.dispatch(&apos;incrementAsync&apos;, { amount: 10 }) // dispatch 传入一个对象 store.dispatch({ type: &apos;incrementAsync&apos;, amount: 10 }) 组合多个action 由于action可以执行异步操作，而store.dispatch 返回『action 回调函数被触发后的返回值』，所以可以在 action 中返回一个 Promise 对象。 actions: { actionA ({ commit }) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { commit(&apos;someMutation&apos;) resolve() }, 1000) }) } } 现在你可以这么做： store.dispatch(&apos;actionA&apos;).then(() =&gt; { // ... }) 然后在另一个 action ： actions: { // ... actionB ({ dispatch, commit }) { return dispatch(&apos;actionA&apos;).then(() =&gt; { commit(&apos;someOtherMutation&apos;) }) } } ModulesVuex 允许我们把 store 分 module（模块）。每一个模块包含各自的状态、mutation、action 和 getter，甚至是嵌套模块， 如下就是它的组织方式： const moduleA = { state: { ... }, mutations: { ... }, actions: { ... }, getters: { ... } } const moduleB = { state: { ... }, mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB } }) store.state.a // -&gt; moduleA&apos;s state store.state.b // -&gt; moduleB&apos;s state //组件中使用 this.$store.state.a.** 模块的 mutations 和 getters方法第一个接收参数是模块的本地状态。 模块的 actions 中，context.state 暴露的是本地状态， context.rootState暴露的才是根状态。 模块的 getters 内，根状态也会作为第三个参数暴露。 ———————————————————————— vue-router cnpm install vue-router - - save-dev //main.js import Vue from &apos;vue&apos; import App from &apos;./App&apos; import VueRouter from &apos;vue-router&apos; import Page1 from &apos;./components/page1&apos; import Page2 from &apos;./components/page2&apos; Vue.use(VueRouter) const routes = [ { path: ‘/page1’, component: Page1 }, { path: &apos;/page2&apos;, component: Page2 } ] const router = new VueRouter({ mode: &apos;history&apos;, //h5模式，url没有/#/,还有一种hash模式就是/#/ base: __dirname, //双下划线 routes }) new Vue({ router, el: &apos;#app&apos;, render: h =&gt; h(App) }).$mount(&apos;#app&apos;) 跳转：&lt;router-link :to=“{name:’page1’}”&gt;点击 的参数：exact:严谨模式;append:在URL后继续追加 传递参数：&lt;router-link :to=“{name:’page1’, params: {id : 1}}”&gt;点击,会跳转到name=”page1”的component,可以通过$route.params.id获取参数id的值 上面代码等同于 this.$router.push({name: ‘page1’, params: { id : 1 }}) 获取URL路由参数，比如path:’/page/:id’,可用$route.params.id获取 支持正则匹配：path: ‘page/:id(\\d+)’ 手动跳转：this.$router.push(‘/bar’) 定义404页面 const Page404 = { template: ` &lt;h1&gt;error 页面走丢了&lt;/h1&gt; ` } //routes 一定要放在routes的最后一个 { path: &apos;*&apos;, component: Page404 } 路由钩子函数 //routes { path: &apos;/foo&apos;, component: Foo, beforeEnter(to, from, next) =&gt;{ next(); //接着执行，打断为next(false) }, beforeLeave(to, from, next) =&gt;{ next(); //接着执行，打断为next(false) } } //组件中 { template: &apos;&apos;, beforeRouteEnter(to, from, next) =&gt;{ next(); //接着执行，打断为next(false) }, beforeRouteLeave(to, from, next) =&gt;{ next(); //接着执行，打断为next(false) } } webpack例子 全局安装webpack/webpack-dev-server cnpm i -g webpack webpack-dev-server cd 到根目录下 cnpm init //初始化package.json cnpm install webpack webpack-dev-server —save-dev //css使用style-loader、css-loader cnpm install css-loader style-loader --save-dev //js使用babel和es6新特性 cnpm install babel-loader babel-core babel-preset-es2015 --save-dev entry: &apos;entry.js&apos;, //入口文件 output: { path: __dirname, //打包文件的存放位置 filename: &apos;bundle.js&apos; //打包的的文件名为bundle.js }, devtool: &apos;source-map&apos;, //使用source-map调试工具，debugger调试 module: { //加载器配置 loaders: [ //.css 文件使用 style-loader 和 css-loader 来处理 { test: /\\.css$/, loader: &apos;style-loader!css-loader&apos; }, //.js 文件使用 babel-loader 来编译处理 { test: /\\.js$/, loader: &apos;babel-loader&apos; }, //.scss 文件使用 style-loader、css-loader 和 sass-loader 来编译处理 { test: /\\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;}, //图片文件使用 url-loader 来处理，小于8kb的直接转为base64 { test: /\\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos;} ] }, resolve: { extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.css&apos;, &apos;jsx&apos;] //自动补全识别后缀 } 根据需要，安装所需要的包 使用jQuery plugins:[ new webpack.ProvidePlugin({ $:&quot;jquery&quot;, jQuery:&quot;jquery&quot;, &quot;window.jQuery&quot;:&quot;jquery&quot; }) ] 运行 ： webpack-dev-server –hot –inline","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://yoursite.com/tags/vuex/"},{"name":"vue-router","slug":"vue-router","permalink":"http://yoursite.com/tags/vue-router/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-02-16T03:53:01.000Z","updated":"2017-04-26T08:16:55.000Z","comments":true,"path":"2017/02/16/hello-world/","link":"","permalink":"http://yoursite.com/2017/02/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server 删除public文件1$ hexo clean 生成public文件1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment git提交 git clone ‘’ git add -A git commit -m “描述” git push -u origin master","categories":[],"tags":[]}]}